Encoding

25 bit immediate data + 7 bit opcode
[31:7]  [6:0]
data    opcode

Internal registers

Name     Index    Size    Purpose
---------------------------------------------------------------------------
r0-r31 | [0:31] | 32bit | CPU registers
imm    | [31+0] | 24bit | Immediate value calculated from instruction encoding, sign extended to 32 bits on read if needed
oper   | [31+1] | 12bit | Packed bits pointing at CPU register indices
creg   | [31+2] |  1bit | Compare result register
lreg   | [31+3] | 32bit | Pending load bit mask for CPU registers
sreg   | [31+4] | 32bit | Pending store bit mask for CPU registers
addr   | [31+5] | 32bit | Data address register
ofst   | [31+6] | 32bit | Offset register

---------------------------------------------------------------------------

Opcodes
wait(c) -> wait for conditional to become true
regs(r) -> if high bit is set, it's an internal register, otherwise it's a CPU register
mem() -> always starts a read request at addr+offset

????????_????????.BBBB_BBAAA_AAA_0000: rsel A, B:    oper <= {B, A};                           Select the two operand registers for following instruction
????????_????????.????_?????_OOO_0001: move.op:      regs[A] <= op(regs[B]);                   Branch writes to PC with op equal to nothing or a compare
????????_????????.????_?????_?CC_0010: cmp.cop:      creg <= op(regs[A], regs[B]) ? 1 : 0;     Compare register A to register B and set creg to result
????????_????????.????_?????_???_0011: csel:         regs[A] <= creg ? regs[A] : regs[B];      Select either register A or register B to replace contents of register A
????????_????????.????_?????_???_0100: load:         regs[A] <= mem(); lreg[A] <= 1;           Start load into register A and mark it as busy-for-load
????????_????????.????_?????_???_0101: lwait target: wait(lreg[A]==0);                         Wait for target register's lflg bit to become zero (only inserted if a lflg register is being read)
????????_????????.????_?????_??U_0110: unblock.unit:                                           Execute unit will unblock the given unit
????????_????????.????_?????_??U_0111: waitfor.unit:                                           Execute unit will wait for the given unit to unblock it
????????_????????.IIII_IIIII_III_1000: ldli I:       imm <= {12'd0, I};                        Load lower 12 bits of immediate register (always clears the upper 12 bits to 0)
????????_????????.IIII_IIIII_III_1001: ldhi I:       imm[23:12] <= I;                          Load upper 12 bits of immediate register (to be sign extended on read)
????????_????????.IIII_IIIII_III_1010: ldla I:                                                 Load lower 12 bits of address register (always clears the upper 12 bits to 0)
????????_????????.IIII_IIIII_III_1011: ldha I:                                                 Load upper 12 bits of address register
????????_????????.????_?????_???_1100: store:
????????_????????.????_?????_???_1101: 
????????_????????.????_?????_???_1110: 
????????_????????.????_?????_?TT_1111: exception.etype

.op(O):
  000: adi: transient add immediate to source)
  001: ado: transient add offset to source
  010: if: conditional move depending on last compare result
  011: 
  100: 
  101: 
  110: 
  111: copy: no op, pass through copy
.cop(C):
  00: eq
  01: less
  10: zero
  11: greaterequal
.unit(U):
  0: fetchunit
  1: other(none)
.etype(T):
  00: illegal instruction
  01: hw_interrupt(external or timer) or exception
  10: other(none)
  11: other(none)

Example

00000000 <_start>:
   0:	0000b197          	auipc	gp,0xb
   4:	03c1a183          	lw	gp,60(gp) # b03c <_GLOBAL_OFFSET_TABLE_+0x4>
   8:	f14024f3          	csrr	s1,mhartid
   c:	00849493          	slli	s1,s1,0x8
  10:	00020937          	lui	s2,0x20
  14:	f0090913          	addi	s2,s2,-256 # 1ff00 <__global_pointer$+0x14680>
  18:	40990933          	sub	s2,s2,s1
  1c:	00090113          	mv	sp,s2
  20:	00010413          	mv	s0,sp
  24:	04049a63          	bnez	s1,78 <workerhartstart>
  28:	0000b517          	auipc	a0,0xb
  2c:	02c52503          	lw	a0,44(a0) # b054 <_GLOBAL_OFFSET_TABLE_+0x1c>
  30:	0000b617          	auipc	a2,0xb
  34:	03862603          	lw	a2,56(a2) # b068 <_GLOBAL_OFFSET_TABLE_+0x30>
  38:	40a60633          	sub	a2,a2,a0
  3c:	00000593          	li	a1,0
  40:	050000ef          	jal	ra,90 <memset>
  44:	0000b517          	auipc	a0,0xb
  48:	01852503          	lw	a0,24(a0) # b05c <_GLOBAL_OFFSET_TABLE_+0x24>
  4c:	00050a63          	beqz	a0,60 <noatexitfound>
  50:	00001517          	auipc	a0,0x1
  54:	0000b517          	auipc	a0,0xb
  58:	ff452503          	lw	a0,-12(a0) # b048 <_GLOBAL_OFFSET_TABLE_+0x10>
  5c:	4e5060ef          	jal	ra,6d40 <atexit>

00000060 <noatexitfound>:
  60:	55d060ef          	jal	ra,6dbc <__libc_init_array>
  64:	00012503          	lw	a0,0(sp)
  68:	00410593          	addi	a1,sp,4
  6c:	00000613          	li	a2,0
  70:	14d0606f          	j	69bc <main>
  74:	00100073          	ebreak

00000078 <workerhartstart>:
  78:	00012503          	lw	a0,0(sp)
  7c:	00410593          	addi	a1,sp,4
  80:	00000613          	li	a2,0
  84:	1310606f          	j	69b4 <_Z10workermainv>
  88:	00100073          	ebreak