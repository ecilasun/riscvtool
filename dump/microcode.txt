Internal registers

Name     Index    Size    Purpose
---------------------------------------------------------------------------
r0-r31 | [0:31] | 32bit | CPU registers
PC     | [31+0] | 32bit | CPU program counter (read only from exec side)
imm    | [31+1] | 24bit | Immediate value calculated from instruction encoding, sign extended to 32 bits on read if needed
oper   | [31+2] | 12bit | Packed bits pointing at CPU register indices
creg   | [31+3] |  1bit | Compare result register
lreg   | [31+4] | 32bit | Pending load bit mask for CPU registers
sreg   | [31+5] | 32bit | Pending store bit mask for CPU registers
addr   | [31+6] | 32bit | Data address register
ofst   | [31+7] | 32bit | Offset register
jump   | [31+8] | 32bit | Jump destination register

---------------------------------------------------------------------------

Opcodes
wait(c) -> wait for conditional to become true
regs(r) -> if high bit is set, it's an internal register, otherwise it's a CPU register
mem() -> always starts a read request at addr+offset
*The immediate value in the instruction is already extracted and sign extended into the imm register

????????_????????.BBBB_BBAAA_AAA_0000: rsel A, B:    oper <= {B, A};                           Select the two operand registers for following instruction
????????_????????.????_?????_OOO_0001: move.op:      regs[A] <= op(regs[B]);                   Branch writes to PC with op equal to nothing or a compare
????????_????????.????_?????_?CC_0010: cmp.cop:      creg <= op(regs[A], regs[B]) ? 1 : 0;     Compare register A to register B and set creg to result
????????_????????.????_?????_???_0011: csel:         regs[A] <= creg ? regs[A] : regs[B];      Select either register A or register B to replace contents of register A
????????_????????.????_?????_???_0100: load:         regs[A] <= mem();                         Start load into register A
????????_????????.????_?????_???_0101: lwait:        wait(lreg[A]==0);                         Wait for target register's lreg bit to become zero (inserted when a lreg register is being read from)
????????_????????.????_?????_??U_0110: unblock.unit:                                           Execute unit will unblock the given unit
????????_????????.????_?????_??U_0111: waitfor.unit:                                           Execute unit will wait for the given unit to unblock it
????????_????????.????_?????_???_1000: store:        mem() <= regs[A];
????????_????????.????_??VRR_RRR_1001: setlreg R,V   lreg[R] <= V;                             Set or clear lreg to bit V
????????_????????.????_??VRR_RRR_1010: setsreg R,V   sreg[R] <= V;                             Set or clear sreg to bit V
????????_????????.????_?????_???_1011: 
????????_????????.????_?????_???_1100: 
????????_????????.????_?????_???_1101: 
????????_????????.????_?????_???_1110: noop:
????????_????????.????_?????_?TT_1111: exception.etype

.op(O):
  000: adi: transient add immediate to source)
  001: ado: transient add offset to source
  010: if: conditional move depending on last compare result
  011: 
  100: 
  101: 
  110: 
  111: copy: no op, pass through copy
.cop(C):
  00: eq
  01: less
  10: zero
  11: greaterequal
.unit(U):
  0: fetchunit
  1: other(none)
.etype(T):
  00: illegal instruction
  01: hw_interrupt(external or timer) or exception
  10: other(none)
  11: other(none)

Example

00000000 <_start>:
   0:	0000b197          	auipc	gp,0xb
                  rsel gp, PC // imm loaded with 0x0000B000
                  move.adi // gp <= PC + imm
   4:	03c1a183          	lw	gp,60(gp) # b03c <_GLOBAL_OFFSET_TABLE_+0x4>
                  rsel addr, gp // imm loaded with 60
                  move.adi // addr <= gp + imm
                  rsel gp, zero
                  setlreg 1 // mark gp busy for load
                  load // start load
   8:	f14024f3          	csrr	s1,mhartid
                  rsel addr, zero // imm loaded with address of mhartid
                  move.adi // addr <= 0 + imm
                  rsel s1, zero
                  setlreg 1 // mark s1 busy for load
                  load.word
   c:	00849493          	slli	s1,s1,0x8
                  lwait // wait for s1 to become available (still selected), imm loaded with 8
                  move.sll // s1 <= s1 << imm
  10:	00020937          	lui	s2,0x20
                  rsel s2, zero // imm loaded with 20
                  move.ui // s2 <= unsigned(imm)
  14:	f0090913          	addi	s2,s2,-256 # 1ff00 <__global_pointer$+0x14680>
                  // imm loaded with -256
                  move.adi // s2 already selected, s2 <= s2 + imm
  18:	40990933          	sub	s2,s2,s1
                  rsel s2, s1
                  move.sub // s2 <= s2 - s1
  1c:	00090113          	mv	sp,s2
                  rsel sp, s2
                  move.copy // sp <= s2
  20:	00010413          	mv	s0,sp
                  rsel s0, sp
                  move.copy // s0 <= sp
  24:	04049a63          	bnez	s1,78 <workerhartstart>
                  rsel s1, PC // imm is loaded with sign extended 78, jump loaded with PC + 4
                  cmp.nez // creg <= s1 != 0 ? 1:0
                  rsel tmp, PC // NOTE: okay to overwrite s1 instead?
                  move.adi // tmp <= PC + imm
                  csel jump, tmp // if creg==1, jump <= PC + imm
                  unblock.fetchunit // can now resume from new PC which is 'jump' register's value
  28:	0000b517          	auipc	a0,0xb
                  rsel ao, PC // imm loaded with 0x0000B000
                  move.adi // a0 <= PC + imm
  2c:	02c52503          	lw	a0,44(a0) # b054 <_GLOBAL_OFFSET_TABLE_+0x1c>
                  rsel addr, a0 // imm loaded with 44
                  move.adi // addr <= a0 + imm
                  rsel a0, zero
                  setlreg 1 // mark a0 busy for load
                  load // start load
  30:	0000b617          	auipc	a2,0xb
  34:	03862603          	lw	a2,56(a2) # b068 <_GLOBAL_OFFSET_TABLE_+0x30>
  38:	40a60633          	sub	a2,a2,a0
  3c:	00000593          	li	a1,0
  40:	050000ef          	jal	ra,90 <memset>
  44:	0000b517          	auipc	a0,0xb
  48:	01852503          	lw	a0,24(a0) # b05c <_GLOBAL_OFFSET_TABLE_+0x24>
  4c:	00050a63          	beqz	a0,60 <noatexitfound>
  50:	00001517          	auipc	a0,0x1
  54:	0000b517          	auipc	a0,0xb
  58:	ff452503          	lw	a0,-12(a0) # b048 <_GLOBAL_OFFSET_TABLE_+0x10>
  5c:	4e5060ef          	jal	ra,6d40 <atexit>

00000060 <noatexitfound>:
  60:	55d060ef          	jal	ra,6dbc <__libc_init_array>
  64:	00012503          	lw	a0,0(sp)
  68:	00410593          	addi	a1,sp,4
  6c:	00000613          	li	a2,0
  70:	14d0606f          	j	69bc <main>
  74:	00100073          	ebreak

00000078 <workerhartstart>:
  78:	00012503          	lw	a0,0(sp)
  7c:	00410593          	addi	a1,sp,4
  80:	00000613          	li	a2,0
  84:	1310606f          	j	69b4 <_Z10workermainv>
  88:	00100073          	ebreak