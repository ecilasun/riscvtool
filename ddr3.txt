/*wire ui_clk;
wire ui_clk_sync_rst;

logic [27:0] app_addr = 32'h00040000;	// Skip BRAM part
logic [2:0] app_cmd = 3'b001;			// READ:001, WRITE:000
logic app_en = 1'b0;

logic [127:0] app_wdf_data = 128'hBAADD00DBAADF00DDECAF000B0ADBAAD;
logic app_wdf_wren = 1'b0;
logic app_wdf_end = 1'b0;
logic [15:0] app_wdf_mask = 16'h0000;

wire [127:0] app_rd_data;
wire app_rd_data_end;
wire app_rd_data_valid;
wire app_rdy;
wire app_wdf_rdy;

wire app_sr_active, app_ref_ack, app_zq_ack;
wire [11:0] device_temp; // Unused, but could map to some memory address if needed

DDR37SeriesGen DDR3Memory (
	// Memory interface ports
	.ddr3_addr                      (ddr3_addr),
	.ddr3_ba                        (ddr3_ba),
	.ddr3_cas_n                     (ddr3_cas_n),
	.ddr3_ck_n                      (ddr3_ck_n),
	.ddr3_ck_p                      (ddr3_ck_p),
	.ddr3_cke                       (ddr3_cke),
	.ddr3_ras_n                     (ddr3_ras_n),
	.ddr3_reset_n                   (ddr3_reset_n),
	.ddr3_we_n                      (ddr3_we_n),
	.ddr3_dq                        (ddr3_dq),
	.ddr3_dqs_n                     (ddr3_dqs_n),
	.ddr3_dqs_p                     (ddr3_dqs_p),
	.ddr3_cs_n                      (ddr3_cs_n),
	.ddr3_dm                        (ddr3_dm),
	.ddr3_odt                       (ddr3_odt),
	// Application interface ports
	.app_addr                       (app_addr),
	.app_cmd                        (app_cmd),
	.app_en                         (app_en),
	.app_wdf_data                   (app_wdf_data),
	.app_wdf_end                    (app_wdf_end),
	.app_wdf_wren                   (app_wdf_wren),
	.app_rd_data                    (app_rd_data),
	.app_rd_data_end                (app_rd_data_end),
	.app_rd_data_valid              (app_rd_data_valid),
	.app_rdy                        (app_rdy),
	.app_wdf_rdy                    (app_wdf_rdy),
	.app_sr_req                     (1'b0),
	.app_ref_req                    (1'b0),
	.app_zq_req                     (1'b0),
	.app_sr_active                  (app_sr_active),
	.app_ref_ack                    (app_ref_ack),
	.app_zq_ack                     (app_zq_ack),
	.app_wdf_mask                   (app_wdf_mask),
	// UI
	.ui_clk                         (ui_clk),
	.ui_clk_sync_rst                (ui_clk_sync_rst),
	// Ctl
	.sys_clk_i                      (ddrclock),
	.clk_ref_i                      (ddrclockref),
	.init_calib_complete            (init_calib_complete),
	.device_temp                    (device_temp),
	.sys_rst                        (reset_n)
);

localparam CMD_WRITE = 3'b000;
localparam CMD_READ = 3'b001;

localparam DDR3_IDLE = 2'b00;
localparam DDR3_WAIT_CMD = 2'b01;
localparam DDR3_READ_END = 2'b10;
localparam DDR3_WRITE_END = 2'b11;

logic [1:0] ddr3state = DDR3_IDLE;
wire ddr3cmdfull, ddr3cmdempty, ddr3cmdvalid;
logic [64:0] ddr3cmdin;
logic ddr3cmdwe = 1'b0, ddr3cmdre = 1'b0;
wire [64:0] ddr3cmdout;
logic [127:0] ddr3dataout = 128'hBAAD5AADBAAD5AADBAAD5AADBAAD5AAD;

ddr3cmd ddr3rwfifo(
	.full(ddr3cmdfull),
	.din(ddr3cmdin),
	.wr_en(ddr3cmdwe),
	.wr_clk(cpuclock),
	.empty(ddr3cmdempty),
	.dout(ddr3cmdout),
	.valid(ddr3cmdvalid),
	.rd_en(ddr3cmdre),
	.rd_clk(ui_clk),
	.rst(reset_p) );

always @(posedge ui_clk) begin
	if (ui_clk_sync_rst) begin

		ddr3state <= DDR3_IDLE;

	end else begin
		case (ddr3state)

			DDR3_IDLE: begin // IDLE
				// If we have something in the FIFO and the DDR3 controller is ready
				if (~ddr3cmdempty & app_rdy & app_wdf_rdy) begin
					// Pull command from the queue
					ddr3cmdre <= 1'b1;
					ddr3state <= DDR3_WAIT_CMD;
				end
			end
			
			DDR3_WAIT_CMD: begin
				ddr3cmdre <= 1'b0;
				// Command read complete
				if (ddr3cmdvalid) begin
					// Set up the address (common between read and write) 
					app_addr = ddr3cmdout[59:32]; // Wasteful storage, use 128bit aligned address ddr3cmdout[63:28] instead
					app_en <= 1'b1;
					// Check command read/write flag
					if (ddr3cmdout[64]) begin
						app_cmd = CMD_WRITE;
						app_wdf_wren <= 1'b1;
						app_wdf_end <= 1'b1;
						app_wdf_mask <= 16'hFFFF; // TODO: Write mask comes from address & original write mask
						// Simply replicate incoming data to all DWORDs, mask will select which parts to write
						app_wdf_data <= {ddr3cmdout[31:0], ddr3cmdout[31:0], ddr3cmdout[31:0], ddr3cmdout[31:0]};
						ddr3state <= DDR3_WRITE_END;
					end else begin
						app_cmd = CMD_READ;
						ddr3state <= DDR3_READ_END;
					end
				end
			end

			DDR3_READ_END: begin
				if (app_rdy) begin
					app_en <= 1'b0;
				end
				if (app_rd_data_valid) begin
					ddr3dataout <= app_rd_data;
					ddr3state <= DDR3_IDLE;
				end
			end

			DDR3_WRITE_END: begin
				if (app_rdy) begin
					app_en <= 1'b0;
				end
				if (app_wdf_rdy) begin
					app_wdf_wren <= 1'b0;
					app_wdf_end <= 1'b0;
					ddr3state <= DDR3_IDLE;
				end
			end

		endcase
	end
end*/